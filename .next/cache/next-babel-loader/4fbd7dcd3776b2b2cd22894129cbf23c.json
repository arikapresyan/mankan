{"ast":null,"code":"import { useFormik } from 'formik';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { message } from 'antd';\nimport { selectUser } from '../../../../store/user/reducer';\nimport { getSingleData } from '../../../../store/single-data/action';\nimport { selectSingleData } from '../../../../store/single-data/reducer';\nimport { getInitialValues, MIN_TOTAL } from './constants';\nimport { sendOrder } from '../../../../store/cart/action';\nimport { getOrderSchema } from '../../../../utils/validationSchemas';\nimport { getBonus } from '../../../../constants/utils';\nexport default function useConfirmOrder(handleHideModal, data) {\n  const {\n    messages,\n    formatMessage\n  } = useIntl();\n  const user = useSelector(selectUser);\n  const dispatch = useDispatch();\n  const {\n    paymentDelivery: singleData\n  } = useSelector(selectSingleData);\n  const orderStatus = useSelector(({\n    cart\n  }) => cart.order);\n  const initialValues = useMemo(() => getInitialValues(user), []);\n  const sendOrderAction = useCallback(payload => {\n    dispatch(sendOrder(payload));\n  }, []);\n  const {\n    cartData,\n    promoCodeData,\n    bonusPercent\n  } = data;\n  const fullPrice = useMemo(() => cartData.reduce((a, b) => (a.price * a.count || a) + b.price * b.count, 0), []);\n  const fullNewPrice = useMemo(() => {\n    if (!promoCodeData) return null;\n    const reduce = cartData.reduce((a, b) => (a.price * a.count || a) + b.price * b.count, 0);\n    return promoCodeData ? reduce * (100 - promoCodeData.percent) / 100 : reduce;\n  }, // zexchel\n  [promoCodeData, cartData]);\n  const bonus = useMemo(() => getBonus(fullNewPrice || fullPrice, bonusPercent || 2, 1), [bonusPercent, fullNewPrice, fullPrice]);\n  const deliveryPrice = useMemo(() => (fullNewPrice || fullPrice) > 20000 ? 0 : 800, [fullNewPrice]);\n  const total = useMemo(() => (fullNewPrice || fullPrice) + deliveryPrice, [fullNewPrice, deliveryPrice, fullPrice]);\n  const {\n    0: dateInfo,\n    1: setDateInfo\n  } = useState({\n    time: [],\n    days: []\n  });\n  useEffect(() => {\n    dispatch(getSingleData({\n      data: {\n        name: 'paymentDelivery'\n      }\n    }));\n  }, [getSingleData, dispatch]);\n  useEffect(() => {\n    if (singleData.data && !dateInfo.days.length) {\n      setDateInfo(singleData.data);\n    }\n  }, [singleData]);\n  const validationSchema = useMemo(() => getOrderSchema(messages), [messages]);\n  const formik = useFormik({\n    initialValues,\n    validationSchema,\n\n    onSubmit(values) {\n      if (values.method === 3 && user.bonus < total) {\n        message.warning(messages['local.not_enough_bonus']);\n        return;\n      }\n\n      if (total < MIN_TOTAL) {\n        message.warning(formatMessage({\n          id: 'local.min_price_of_order'\n        }, {\n          price: MIN_TOTAL\n        }));\n        return;\n      }\n\n      const messageTexts = {\n        errorText: messages['local.errorText'],\n        successText: messages['local.successText']\n      };\n      sendOrderAction({\n        values,\n        messageTexts,\n        promo: promoCodeData === null || promoCodeData === void 0 ? void 0 : promoCodeData.code\n      });\n    }\n\n  });\n  useEffect(() => {\n    if (!orderStatus.loading && !orderStatus.error && formik.isSubmitting) handleHideModal();\n  }, [orderStatus]);\n  return {\n    formik,\n    dateInfo,\n    loading: orderStatus.loading,\n    other: {\n      bonus,\n      total,\n      deliveryPrice,\n      fullNewPrice,\n      fullPrice\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}